**⚠️Warning!** This project is in a very early stage of development and is primarily a proof of concept for an application I'm making. It works, but it's raw, unorganized, lacks testing, and most of all is AI-generated to the core. Not recommended for production use.

# Automapper Generator

A CLI ulitity that generates reflection-free Go code for mapping structs with type conversion support.

# Quick start

Create `automapper.json` config file in the same directory as your DTO models are:
```json
{
  "package": "dtos",
  "output": "automappers.go",
  "defaultConverters": [
    {
      "from": "time.Time",
      "to": "string",
      "name": "TimeToString",
      "function": "TimeToJSString"
    }
  ],
  "generateInit": true,
  "externalPackages": [
    {
      "alias": "db",
      "importPath": "git.weirdcat.su/automapper-gen/example/db",
      "localPath": "../db"
    }
  ]
}
```
- `package` should match the name of the package.
- `externalPackages` should list modules that contain source structs for your DTOs. In Our example we add a submodule which defines database models.

Now we need to have the two files with our database models and DTOs, for example:

```go
// db.go
package db

import "time"

type UserDB struct {
	ID         int64
	Username   string
	Password   string
	CreatedAt  time.Time
}
```

```go
// dtos.go
package dtos

//automapper:from=db.UserDB
type UserDTO struct {
	ID        int64
	Username  string
	CreatedAt string `automapper:"converter=jsTime"`
}
```

These sit in different directories. Now if we want to generate mapper functions for `UserDTO`, we need to run the command in the `dtos` directory:
```bash
$ automapper-gen .
```

This will generate a new file `automappers.go` in the current directory with the following content:
```go
// Code generated by automapper-gen. DO NOT EDIT.

package dtos

import (
	"fmt"
	"time"
	"errors"
	"git.weirdcat.su/weirdcat/automapper-gen/example/db"
)

// Converter type for type-safe conversions
type Converter[From any, To any] func(From) (To, error)

// Global converter registry
var converters = make(map[string]interface{})

// RegisterConverter registers a type-safe converter
func RegisterConverter[From any, To any](name string, fn Converter[From, To]) {
	converters[name] = fn
}

// Convert performs a type-safe conversion using a registered converter
func Convert[From any, To any](name string, value From) (To, error) {
	var zero To
	converterIface, ok := converters[name]
	if !ok {
		return zero, fmt.Errorf("converter %s not registered", name)
	}
	converter, ok := converterIface.(Converter[From, To])
	if !ok {
		return zero, fmt.Errorf("converter %s has wrong type", name)
	}
	return converter(value)
}

func init() {
	// Register TimeToString: time.Time -> string
	RegisterConverter[time.Time, string]("TimeToString", TimeToJSString)
}

// TimeToJSString converts time.Time to JavaScript ISO 8601 string
func TimeToJSString(t time.Time) (string, error) {
	return t.Format(time.RFC3339), nil
}

// MapFromUserDB maps from db.UserDB to UserDTO
func (d *UserDTO) MapFromUserDB(src *db.UserDB) error {
	if src == nil {
		return errors.New("source is nil")
	}

	d.ID = src.ID
	d.Username = src.Username
	{
		var err error
		d.CreatedAt, err = Convert[time.Time, string]("jsTime", src.CreatedAt)
		if err != nil {
			return fmt.Errorf("converting field CreatedAt: %w", err)
		}
	}

	return nil
}
```
The function `(d *UserDTO) MapFromUserDB(src *db.UserDB) error` can now be used to map contents from a `UserDB` model directly into an instance of `UserDTO`. Cheers!
