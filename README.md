# Automapper Generator
[![Go Version](https://img.shields.io/badge/go-1.25.5-blue.svg)](https://go.dev/)
[![License](https://img.shields.io/badge/license-MIT-green.svg)](LICENSE)

An easy-to-use CLI utility that generates reflection-free Go 1.18+ code for mapping structs with type conversion support.

> **‚ö†Ô∏è Development Status**: This project is in early development. There are yet no integrated tests, and some things may be subject to change. Any feedback is greatly appreciated!

## Features

- üöÄ **Zero Reflection**: Generates type-safe code at compile time
- üîÑ **Type Conversion**: Built-in converter system with custom converters
- üì¶ **Remote Packages**: Map from structs in any Go module (local or remote)
- üåê **Module Cache Support**: Automatically loads types from Go's module cache
- üè∑Ô∏è **Flexible Mapping**: Tag-based field mapping and transformations
- üéØ **Type Safety**: Compile-time type checking with generics
- ‚ö° **Performance**: Direct field assignments, no runtime overhead

[![Marilyn Manson - No Reflection](https://img.youtube.com/vi/DOj3wDlr_BM/0.jpg)](https://www.youtube.com/watch?v=DOj3wDlr_BM)

## Table of Contents

- [How It Works](#how-it-works)
- [Installation](#installation)
- [Quick Start](#quick-start)
- [Configuration](#configuration)
- [Usage](#usage)
  - [Remote Modules](#remote-modules)
  - [Basic Mapping](#basic-mapping)
  - [Multiple Source Structs](#multiple-source-structs)
  - [Field Tags](#field-tags)
  - [Converters](#converters)
  - [Nested Structs](#nested-structs)
- [Examples](#examples)

## How It Works

1. **Parse Configuration**: Reads `automapper.json` to understand the project setup
2. **Parse Source Code**: Uses Go's AST parser to analyze structs and fields
3. **Extract Annotations**: Finds `// automapper:from=...` comments on DTOs
4. **Match Fields**: Maps source fields to target fields using name transforms and tags
5. **Generate Code**: Uses [jennifer](https://github.com/dave/jennifer) to generate type-safe Go code
6. **Write Output**: Creates the mapper file with all MapFrom methods

### Generated Code Structure

```go
/*
Code generated by automapper-gen. DO NOT EDIT.
Learn more: https://git.weirdcat.su/weirdcat/automapper-gen
*/

package dtos

import (
	"errors"
	"fmt"
	db "git.weirdcat.su/weirdcat/automapper-gen/example/db"
	"sync"
	"time"
)

// Converter type for type-safe conversions
type Converter[From any, To any] func(From) (To, error)

// Global converter registry (thread-safe)
var converters = make(map[string]any)
var convertersMu sync.RWMutex

// RegisterConverter registers a type-safe converter
func RegisterConverter[From any, To any](name string, fn Converter[From, To]) {
	convertersMu.Lock()
	defer convertersMu.Unlock()
	converters[name] = fn
}

// Convert performs a type-safe conversion using a registered converter
func Convert[From any, To any](name string, value From) (To, error) {
	var zero To
	convertersMu.RLock()
	converterIface, ok := converters[name]
	convertersMu.RUnlock()
	if !ok {
		return zero, fmt.Errorf("converter %s not registered", name)
	}
	converter, ok := converterIface.(Converter[From, To])
	if !ok {
		return zero, fmt.Errorf("converter %s has wrong type", name)
	}
	return converter(value)
}

func init() {
	RegisterConverter("TimeToString", TimeToJSString)
	RegisterConverter("RoleEnum", StrRoleToEnum)
	RegisterConverter("InterestEnums", StrInterestsToEnums)
}

// TimeToJSString converts time.Time to JavaScript ISO 8601 string
func TimeToJSString(t time.Time) (string, error) {
	return t.Format(time.RFC3339), nil
}

// MapFromUserDB maps from db.UserDB to UserDTO
func (d *UserDTO) MapFromUserDB(src *db.UserDB) error {
	if src == nil {
		return errors.New("source is nil")
	}

	d.ID = src.ID
	d.Username = src.Username
	{
		var err error
		d.Role, err = Convert[string, Role]("RoleEnum", src.Role)
		if err != nil {
			return fmt.Errorf("converting field Role: %w", err)
		}
	}
	if src.About != nil {
		d.About = *src.About
	}
	// About: nil pointer will result in zero value
	{
		d.Pets = make([]PetDTO, len(src.Pets))
		for i, item := range src.Pets {
			if err := d.Pets[i].MapFromPetDB(&item); err != nil {
				return fmt.Errorf("mapping nested field Pets[%d]: %w", i, err)
			}
		}
	}
	if src.FeaturedAchievement != nil {
		var nested AchievementDTO
		if err := nested.MapFromAchievementDB(src.FeaturedAchievement); err != nil {
			return fmt.Errorf("mapping nested field FeaturedAchievement: %w", err)
		}
		d.FeaturedAchievement = nested
	}
	// FeaturedAchievement: nil pointer will result in zero value
	{
		var err error
		d.Interests, err = Convert[[]string, []Interest]("InterestEnums", src.Interests)
		if err != nil {
			return fmt.Errorf("converting field Interests: %w", err)
		}
	}
	if src.Birthday != nil {
		var err error
		var result string
		result, err = Convert[time.Time, string]("TimeToString", *src.Birthday)
		if err != nil {
			return fmt.Errorf("converting field Birthday: %w", err)
		}
		d.Birthday = &result
	}
	// Birthday: nil pointer will result in nil
	{
		var err error
		d.CreatedAt, err = Convert[time.Time, string]("TimeToString", src.CreatedAt)
		if err != nil {
			return fmt.Errorf("converting field CreatedAt: %w", err)
		}
	}

	return nil
}

// MapFromPetDB maps from db.PetDB to PetDTO
func (d *PetDTO) MapFromPetDB(src *db.PetDB) error {
	if src == nil {
		return errors.New("source is nil")
	}

	d.ID = src.ID
	d.Name = src.Name
	{
		var err error
		d.Interests, err = Convert[[]string, []Interest]("InterestEnums", src.Interests)
		if err != nil {
			return fmt.Errorf("converting field Interests: %w", err)
		}
	}
	if src.Birthday != nil {
		var err error
		var result string
		result, err = Convert[time.Time, string]("TimeToString", *src.Birthday)
		if err != nil {
			return fmt.Errorf("converting field Birthday: %w", err)
		}
		d.Birthday = &result
	}
	// Birthday: nil pointer will result in nil
	{
		var err error
		d.CreatedAt, err = Convert[time.Time, string]("TimeToString", src.CreatedAt)
		if err != nil {
			return fmt.Errorf("converting field CreatedAt: %w", err)
		}
	}

	return nil
}

// MapFromAchievementDB maps from db.AchievementDB to AchievementDTO
func (d *AchievementDTO) MapFromAchievementDB(src *db.AchievementDB) error {
	if src == nil {
		return errors.New("source is nil")
	}

	d.ID = src.ID
	d.Title = src.Title
	d.Description = src.Description
	{
		var err error
		d.CreatedAt, err = Convert[time.Time, string]("TimeToString", src.CreatedAt)
		if err != nil {
			return fmt.Errorf("converting field CreatedAt: %w", err)
		}
	}

	return nil
}
```

## Installation

### From Source

```bash
# Clone the repository
git clone https://git.weirdcat.su/weirdcat/automapper-gen.git
cd automapper-gen

# Build and install
make install

# Or build only
make build
```

### Using Go Install

```bash
go install git.weirdcat.su/weirdcat/automapper-gen/cmd/automapper-gen@latest
```

## Quick Start

### 1. Create Configuration

Head to the directory where the destination structs or DTOs are supposed to be.
Create an `automapper.json`:

```json
{
  "output": "automappers.go",
  "defaultConverters": [
    {
      "name": "TimeToString",
      "function": "TimeToJSString"
    }
  ],
  "externalPackages": [
    {
      "alias": "db",
      "importPath": "git.weirdcat.su/weirdcat/automapper-gen/example/db",
      "localPath": "../db"
    }
  ]
}
```
Note that since your source structs (e.g. database models) are most likely in a different package, we have to specify the package in `externalPackages`. In this example we use a database package from the same go module which is located in `./example/db`. The `alias` option helps to avoid name collisions in the generated file when there are multiple external packages.

You may also use the `localPath` parameter which overrides the `importPath`. This may be useful if the generator is unable to discover a local package otherwise.

**Note**: External packages are normally loaded directly from Go's module cache. The package simply needs to be installed and added to `externalPackages` via the `importPath`.

### 2. Define Your Structs

**Database Model** (`db/models.go`):
```go
package db

import "time"

type UserDB struct {
    ID        int64
    Username  string
    Email     string
    Password  string
    CreatedAt time.Time
    UpdatedAt time.Time
}
```
This is what the generator is going to map from.

**DTO Model** (`dtos/user.go`):
```go
package dtos

//automapper:from=db.UserDB
type UserDTO struct {
    ID        int64
    Username  string
    Email     string
    CreatedAt string `automapper:"converter=TimeToJSString"`
    UpdatedAt string `automapper:"converter=TimeToJSString"`
}
```
This is the destination struct that the generator will attempt to map the previous struct to.

To spice things up, we decided that we want to convert the timestamps into another representation
using one of the built-in type converters.

Notice how the database model requires none of our tags or annotations. This is a design choice
since we wanted to have compatibility with database model generators that would otherwise overwrite
the extra information. This makes the tool work especially well with the SQL-compiler [sqlc](https://github.com/sqlc-dev/sqlc).

### 3. Generate Mappers

Simply run the command in the second directory:
```bash
# From the dtos directory
automapper-gen .
```

Great, the code has been generated and written into `automappers.go` in the same directory.

Apart from the automated boilerplate, the file declares methods for the destination structs
that allow mapping from the specified source structs:

```go
dto := &dtos.UserDTO{}
dto.MapFromUserDB(user)
```

the methods always follow the pattern `.MapFrom{Source}(src {Source})`.

Automapper Generator utilizes its own validation system to find errors and warn the user
about potential problems. However, if it fails and still generates faulty code, we are
still safe, since the code will not compile and the problem will be noticed immediately,
unlike with reflection-based mappers.

### 4. Use the Generated Code

Usage of the generated code is straightforward:

```go
package main

import (
    "fmt"
    "time"
    "yourproject/db"
    "yourproject/dtos"
)

func main() {
    // Source data
    user := &db.UserDB{
        ID:        1,
        Username:  "john_doe",
        Email:     "john@example.com",
        Password:  "hashed_password",
        CreatedAt: time.Now(),
        UpdatedAt: time.Now(),
    }

    // Map to DTO
    dto := &dtos.UserDTO{}
    if err := dto.MapFromUserDB(user); err != nil {
        panic(err)
    }

    fmt.Printf("User: %+v\n", dto)
    // Output: User: {ID:1 Username:john_doe Email:john@example.com CreatedAt:2024-01-05T10:30:00Z UpdatedAt:2024-01-05T10:30:00Z}
}
```

**Note**: The `TimeToJSString` converter function is built-in.

## Configuration

### Configuration File (`automapper.json`)

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `package` | string | Yes | Target package name |
| `output` | string | No | Output filename (default: "automappers.go") |
| `fieldNameTransform` | string | No | Field name transformation ("snake_to_camel", default) |
| `nilPointersForNull` | bool | No | Use nil pointers for null values |
| `externalPackages` | array | No | External packages to parse |

### External Packages

External packages are loaded directly from Go's module cache, making it easy to map from types in any Go module:

```json
{
  "externalPackages": [
    {
      "alias": "db",
      "importPath": "github.com/yourorg/project/db"
    },
    {
      "alias": "models",
      "importPath": "git.example.com/team/service/models"
    }
  ]
}
```

**Local Development**: If you're working on a module locally and want to use local changes:

```json
{
  "externalPackages": [
    {
      "alias": "db",
      "importPath": "github.com/yourorg/project/db",
      "localPath": "../db"
    }
  ]
}
```

The generator will try the local path first, then fall back to the module cache.

## Usage

### Remote Modules

One of the key features is the ability to map from types in any Go module, whether it's in your repository or a completely separate one:

#### Example: Mapping from a Different Repository

**Repository 1** (`git.weirdcat.su/test/prj1`):
```go
// bd/models.go
package bd

import "time"

type User struct {
    ID        int64
    Username  string
    CreatedAt time.Time
}
```

**Repository 2** (`git.weirdcat.su/test/prj2`):
```json
// dto/automapper.json
{
  "package": "dto",
  "output": "automappers.go",
  "externalPackages": [
    {
      "alias": "db",
      "importPath": "git.weirdcat.su/test/prj1/bd"
    }
  ]
}
```

```go
// dto/user.go
package dto

//automapper:from=db.User
type UserDTO struct {
    ID        int64
    Username  string
    CreatedAt string `automapper:"converter=TimeToJSString"`
}
```

**Prerequisites**: Make sure the external module is in your `go.mod`:
```bash
go get git.weirdcat.su/test/prj1
```

Then generate:
```bash
cd dto
automapper-gen .
```

The generator will load the `bd` package from your module cache and generate the appropriate mappers!

### Basic Mapping

```go
//automapper:from=SourceStruct
type TargetDTO struct {
    Field1 string
    Field2 int
}
```

### Multiple Source Structs

It is possible to specify multiple source structs in the `automapper:from` annotation:

```go
//automapper:from=User,Profile
type UserProfileDTO struct {
    // Will generate MapFromUser and MapFromProfile
    Name  string
    Email string
}
```

Two seperate methods will be created. This is useful when there are two database requests
that return different objects with identical or similar contents.

### Field Tags

#### Skip Field
```go
type UserDTO struct {
    Password string `automapper:"-"`  // Will not be mapped
}
```

#### Custom Field Mapping

We are able to handle field name mismatches using the `field` parameter:

```go
type UserDTO struct {
    Name string `automapper:"field=Full_Name"`  // Maps from Full_Name
}
```

#### Field Converter

More info the [converters section](#converters).

```go
type UserDTO struct {
    CreatedAt string `automapper:"converter=TimeToJSString"`
}
```

#### Combined Tags
```go
type UserDTO struct {
    BirthDate string `automapper:"field=Birthday,converter=TimeToJSString"`
}
```

### Converters

#### Built-in Converter

The following converter is automatically generated and available for use:

- `TimeToJSString`: Converts `time.Time` to the API-friendly string representation

#### Custom Converters

We often have to deal with mismatching data types or want to adjust the format of 
the data. We can automate conversion by implementing custom converters in the package
to do the work for us.

In the same package where we store the destination structs, create a new .go file.
We suggest the name `converters.go`:

```go
package dtos

import (
    "fmt"
    "git.weirdcat.su/weirdcat/automapper-gen/example/types"
)

// Define your converter function
func StrRoleToEnum(role string) (types.Role, error) {
    switch role {
    case "admin":
        return types.RoleAdmin, nil
    case "user":
        return types.RoleUser, nil
    default:
        return types.RoleGuest, fmt.Errorf("unknown role: %s", role)
    }
}

// More convertion functions if we need
func StrInterestsToEnums(interests []string) ([]types.Interest, error) {
    result := make([]types.Interest, len(interests))
    for i, interest := range interests {
        switch interest {
        case "coding":
            result[i] = types.InterestCoding
        case "music":
            result[i] = types.InterestMusic
        default:
            return nil, fmt.Errorf("unknown interest: %s", interest)
        }
    }
    return result, nil
}
```

Converters must follow these function signatures, accepting value A and returning values B, error. 

Update your `automapper.json` to include your converters:

```json
{
  "package": "dtos",
  "output": "automappers.go",
  "defaultConverters": [
    {
      "name": "TimeToString",
      "function": "TimeToJSString"
    },
    {
      "name": "RoleEnum",
      "function": "StrRoleToEnum"
    },
    {
      "name": "InterestEnums",
      "function": "StrInterestsToEnums"
    }
  ],
  "externalPackages": [
    {
      "alias": "db",
      "importPath": "git.weirdcat.su/weirdcat/automapper-gen/example/db"
    }
  ]
}
```

The `name` parameter defines the tag which will be used in our destination structs to mark the conversion
strategy for a given field.

The `function` parameter references the name of the function that we created. The function will be tied to the previously
defined tag `name`.

The generated `automappers.go` will automatically include an `init()` function that registers these converters based on their function signatures.

Use in your DTOs:

```go
type UserDTO struct {
    Role      Role       `automapper:"converter=RoleEnum"`
    Interests []Interest `automapper:"converter=InterestEnums"`
}
```

**Note**: Converter functions must follow the signature `func(T) (U, error)` and be in the same package as your DTOs.

### Nested Structs

The nested struct feature allows automatic mapping of complex nested structures without manual field-by-field copying. When a source struct contains fields that should map to other DTOs, you can use the `dto` tag to trigger automatic nested mapping:

```go
type UserDTO struct {
	ID                  int64
	Username            string
	Pets                []PetDTO       `automapper:"dto=PetDTO"`
	FeaturedAchievement AchievementDTO `automapper:"dto=AchievementDTO"`
}

//automapper:from=db.PetDB
type PetDTO struct {
	ID        int64
	Name      string
}

//automapper:from=db.AchievementDB
type AchievementDTO struct {
	ID          int64
	Title       string
}
```

The generator will recursively handle the nested structures and generate code that reuses
the `MapFrom` methods for the inner structs, so that mapping, convertion and validation will
run normally.

The dto tag can also be combined with other automapper options:

```go
// Just nested DTO
Field DTO `automapper:"dto=TargetDTO"`

// Nested DTO with custom field mapping
Field DTO `automapper:"dto=TargetDTO,field=SourceFieldName"`

// Cannot combine dto with converter (dto takes precedence)
```

## Examples

### Example 1: Basic User Mapping

**Source** (`db/user.go`):
```go
package db

type User struct {
    ID       int64
    Username string
    Email    string
}
```

**DTO** (`dtos/user.go`):
```go
package dtos

//automapper:from=db.User
type UserDTO struct {
    ID       int64
    Username string
    Email    string
}
```

**Usage**:
```go
user := &db.User{ID: 1, Username: "john", Email: "john@example.com"}
dto := &dtos.UserDTO{}
dto.MapFromUser(user)
```

### Example 2: With Type Conversion

**Source** (`db/product.go`):
```go
package db

import "time"

type Product struct {
    ID        int64
    Name      string
    Price     float64
    CreatedAt time.Time
}
```

**DTO** (`dtos/product.go`):
```go
package dtos

//automapper:from=db.Product
type ProductDTO struct {
    ID        int64
    Name      string
    Price     float64
    CreatedAt string `automapper:"converter=TimeToJSString"`
}
```

## Acknowledgments

- [jennifer](https://github.com/dave/jennifer) - Go code generation library
- Inspired by [sqlc](https://github.com/sqlc-dev/sqlc)
- Inspired by AutoMapper in .NET
