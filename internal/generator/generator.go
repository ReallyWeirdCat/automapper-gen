package generator

import (
	"fmt"
	"strings"

	"git.weirdcat.su/weirdcat/automapper-gen/internal/config"
	"git.weirdcat.su/weirdcat/automapper-gen/internal/types"
	"github.com/dave/jennifer/jen"
)

// Generate creates the automapper code file
func Generate(dtos []types.DTOMapping, sources map[string]types.SourceStruct, cfg *config.Config, pkgName string) (*jen.File, error) {
	f := jen.NewFile(pkgName)

	// Add header comment
	f.HeaderComment(
		"Code generated by automapper-gen. DO NOT EDIT.\n" +
		"Learn more: https://git.weirdcat.su/weirdcat/automapper-gen",
	)

	// Build import mapping (alias -> importPath) for external packages
	importMap := buildImportMap(sources)

	// Generate converter infrastructure
	GenerateInfrastructure(f, cfg, importMap)

	// Generate MapFrom methods
	for _, dto := range dtos {
		for _, sourceName := range dto.Sources {
			source, ok := sources[sourceName]
			if !ok {
				return nil, fmt.Errorf("source struct %s not found for DTO %s", sourceName, dto.Name)
			}

			methodName := "MapFrom"
			if len(dto.Sources) > 1 || source.IsExternal {
				methodName = "MapFrom" + ExtractTypeNameWithoutPackage(sourceName)
			}

			GenerateMapFromMethod(f, dto, source, sourceName, methodName, cfg, importMap)
		}
	}

	return f, nil
}

// buildImportMap creates a mapping of package aliases to import paths
func buildImportMap(sources map[string]types.SourceStruct) map[string]string {
	importMap := make(map[string]string)
	for _, source := range sources {
		if source.IsExternal && source.Alias != "" && source.ImportPath != "" {
			importMap[source.Alias] = source.ImportPath
		}
	}
	return importMap
}

// ParseTypeForJen converts a type string to jen.Code with proper imports
func ParseTypeForJen(typeName string, importMap map[string]string) jen.Code {
	// Handle pointers
	if strings.HasPrefix(typeName, "*") {
		return jen.Op("*").Add(ParseTypeForJen(strings.TrimPrefix(typeName, "*"), importMap))
	}

	// Handle slices
	if strings.HasPrefix(typeName, "[]") {
		return jen.Index().Add(ParseTypeForJen(strings.TrimPrefix(typeName, "[]"), importMap))
	}

	// Handle qualified types (e.g., time.Time, db.User)
	if strings.Contains(typeName, ".") {
		parts := strings.Split(typeName, ".")
		if len(parts) == 2 {
			alias := parts[0]
			typeIdent := parts[1]

			// Look up the actual import path from the alias
			if importPath, ok := importMap[alias]; ok {
				return jen.Qual(importPath, typeIdent)
			}

			// Fallback to standard library packages
			return jen.Qual(alias, typeIdent)
		}
	}

	// Simple type
	return jen.Id(typeName)
}

// ParseTypeRefForJen converts a type reference for use in parameters
func ParseTypeRefForJen(typeName string, importMap map[string]string) jen.Code {
	// For type references in parameters, handle package prefixes
	if strings.Contains(typeName, ".") {
		parts := strings.Split(typeName, ".")
		if len(parts) == 2 {
			alias := parts[0]
			typeIdent := parts[1]

			// Look up the actual import path from the alias
			if importPath, ok := importMap[alias]; ok {
				return jen.Qual(importPath, typeIdent)
			}

			// Fallback to standard library packages
			return jen.Qual(alias, typeIdent)
		}
	}

	return jen.Id(typeName)
}

// ExtractBaseType removes pointer and slice prefixes from a type
func ExtractBaseType(typeName string) string {
	typeName = strings.TrimPrefix(typeName, "*")
	typeName = strings.TrimPrefix(typeName, "[]")
	return typeName
}

// ExtractTypeNameWithoutPackage removes package prefix from a type name
func ExtractTypeNameWithoutPackage(typeName string) string {
	if strings.Contains(typeName, ".") {
		parts := strings.Split(typeName, ".")
		return parts[len(parts)-1]
	}
	return typeName
}
