package generator

import (
	"fmt"
	"strings"

	"git.weirdcat.su/weirdcat/automapper-gen/internal/config"
	"git.weirdcat.su/weirdcat/automapper-gen/internal/logger"
	"git.weirdcat.su/weirdcat/automapper-gen/internal/types"
	"github.com/dave/jennifer/jen"
)

// Generate creates the automapper code file
func Generate(
	dtos []types.DTOMapping,
	sources map[string]types.SourceStruct,
	cfg *config.Config,
	pkgName string,
) (*jen.File, error) {
	logger.Verbose("Starting code generation for package: %s", pkgName)

	f := jen.NewFile(pkgName)

	// Add header comment
	f.HeaderComment(
		"Code generated by automapper-gen. DO NOT EDIT.\n" +
			"Learn more: https://git.weirdcat.su/weirdcat/automapper-gen",
	)

	// Build import mapping (alias -> importPath) for external packages
	logger.Verbose("Building import map...")
	importMap := buildImportMap(sources)
	if len(importMap) > 0 {
		logger.Verbose("Import map entries: %d", len(importMap))
		for alias, path := range importMap {
			logger.Debug("  %s -> %s", alias, path)
		}
	}

	// Generate converter infrastructure
	logger.Verbose("Generating converter infrastructure...")
	GenerateInfrastructure(f, cfg, importMap)
	logger.Verbose("Generated converter infrastructure with %d default converters", len(cfg.DefaultConverters))

	// Generate MapFrom methods
	logger.Verbose("Generating MapFrom methods for %d DTOs...", len(dtos))
	totalMethods := 0

	for i, dto := range dtos {
		logger.Verbose("[%d/%d] Generating methods for DTO: %s", i+1, len(dtos), dto.Name)

		for j, sourceName := range dto.Sources {
			source, ok := sources[sourceName]
			if !ok {
				return nil, fmt.Errorf("source struct %s not found for DTO %s", sourceName, dto.Name)
			}

			methodName := "MapFrom"
			if len(dto.Sources) > 1 || source.IsExternal {
				methodName = "MapFrom" + ExtractTypeNameWithoutPackage(sourceName)
			}

			logger.Debug("  [%d/%d] Generating %s.%s (source: %s)",
				j+1, len(dto.Sources), dto.Name, methodName, sourceName)

			GenerateMapFromMethod(f, dto, source, sourceName, methodName, cfg, importMap)
			totalMethods++
		}
	}

	logger.Verbose("Generated %d MapFrom methods", totalMethods)
	logger.Success("Code generation completed successfully")

	return f, nil
}

// buildImportMap creates a mapping of package aliases to import paths
func buildImportMap(sources map[string]types.SourceStruct) map[string]string {
	importMap := make(map[string]string)
	for _, source := range sources {
		if source.IsExternal && source.Alias != "" && source.ImportPath != "" {
			importMap[source.Alias] = source.ImportPath
		}
	}
	return importMap
}

// ParseTypeForJen converts a type string to jen.Code with proper imports
func ParseTypeForJen(typeName string, importMap map[string]string) jen.Code {
	// Handle pointers
	if after, ok := strings.CutPrefix(typeName, "*"); ok {
		return jen.Op("*").Add(ParseTypeForJen(after, importMap))
	}

	// Handle slices
	if after, ok := strings.CutPrefix(typeName, "[]"); ok {
		return jen.Index().Add(ParseTypeForJen(after, importMap))
	}

	// Handle qualified types (e.g., time.Time, db.User)
	if strings.Contains(typeName, ".") {
		parts := strings.Split(typeName, ".")
		if len(parts) == 2 {
			alias := parts[0]
			typeIdent := parts[1]

			// Look up the actual import path from the alias
			if importPath, ok := importMap[alias]; ok {
				return jen.Qual(importPath, typeIdent)
			}

			// Fallback to standard library packages
			return jen.Qual(alias, typeIdent)
		}
	}

	// Simple type
	return jen.Id(typeName)
}

// ParseTypeRefForJen converts a type reference for use in parameters
func ParseTypeRefForJen(typeName string, importMap map[string]string) jen.Code {
	// For type references in parameters, handle package prefixes
	if strings.Contains(typeName, ".") {
		parts := strings.Split(typeName, ".")
		if len(parts) == 2 {
			alias := parts[0]
			typeIdent := parts[1]

			// Look up the actual import path from the alias
			if importPath, ok := importMap[alias]; ok {
				return jen.Qual(importPath, typeIdent)
			}

			// Fallback to standard library packages
			return jen.Qual(alias, typeIdent)
		}
	}

	return jen.Id(typeName)
}

// ExtractBaseType removes pointer and slice prefixes from a type
func ExtractBaseType(typeName string) string {
	typeName = strings.TrimPrefix(typeName, "*")
	typeName = strings.TrimPrefix(typeName, "[]")
	return typeName
}

// ExtractTypeNameWithoutPackage removes package prefix from a type name
func ExtractTypeNameWithoutPackage(typeName string) string {
	if strings.Contains(typeName, ".") {
		parts := strings.Split(typeName, ".")
		return parts[len(parts)-1]
	}
	return typeName
}
